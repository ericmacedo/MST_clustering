import numpy as np
import time
from sklearn.metrics import silhouette_score


class Kruskal:
    def __init__(self, dataset: np.array, k: int):
        start = time.time()

        # DATASET
        self.dataset = dataset
        self.k = k
        self.n = dataset.shape[0]

        '''
            CALCULATE DISTANCES
            N x N matrix
            -
            x -
            x x -
            x x x -
            x x x x -
            x x x x x -
            x x x x x x -
            ...

            m = ((n - 1)*(a1 + (n - 1))/2

            O(n²/2)
        '''
        self.m = int(((self.n - 1)*(1 + (self.n - 1)))/2)
        self.distanceIndex = np.zeros(self.m, dtype='float32, int32, int32')

        # GRAPH
        self.classes = np.array(range(0, self.n))  # VECTOR OF CLASSES
        self.sizes = [1 for i in range(0, self.n)]  # VECTOR OF SIZES
        self.classeCount = self.n  # COUNT FOR EXISTING GROUPS

        self.start()

        # DATA ANALYSIS
        self.silhouette = silhouette_score(dataset, self.classes, metric='euclidean')

        end = time.time()

        self.time = end - start

    def find(self, i: int):
        while(i != self.classes[i]):
            self.classes[i] = self.classes[self.classes[i]]
            i = self.classes[i]
        return i

    def union(self, x: int, y: int):
        x = self.find(x)
        y = self.find(y)

        if(x == y):
            return

        self.classeCount -= 1  # DECREMENT ON EACH UNION
        if(self.sizes[x] < self.sizes[y]):
            self.sizes[y] += self.sizes[x]
            self.classes[x] = y
        else:
            self.sizes[x] += self.sizes[y]
            self.classes[y] = x

    # CALCULATES THE EUCLIDEAN DISTANCE OF X[] AND Y[]
    def euclidean(self, x: np.array, y: np.array):
        return np.sqrt((np.sum((x - y)**2)))

    # CALCULATES THE DISTANCE VECTOR
    def distances(self):
        count = 0
        '''
            O(n²/2) or O(m)
            Calculate the distances
        '''
        for i in range(0, self.n):
            for j in range(0, i):
                distance = self.euclidean(self.dataset[i], self.dataset[j])
                self.distanceIndex[count][0] = distance
                self.distanceIndex[count][1] = i
                self.distanceIndex[count][2] = j
                count += 1

        '''
            SORT ARRAY OF DISTANCES
            O(m log m)
        '''
        self.distanceIndex.view('float32,int32,int32').sort(order=['f0'], axis=0)

    def generate_graph(self):
        '''
            CALCULATES THE MST GENERATED BY DECREMENTING THE N GROUPS IN EACH
            UNION OPERATION TILL IT REACHES K GROUPS
        '''
        for i in self.distanceIndex:
            if(self.classeCount == self.k):  # IF TRUE -> REACHED K GROUPS
                break
            self.union(i[1], i[2])  # IF TRUE -> VALID EDGE

    def normatize(self):
        '''
            REDUCES THE HIERARCHY ON THE GROUP TREE TO O(1)
        '''
        for i in range(0, self.n):
            self.classes[i] = self.find(i)

        '''
            NOMALIZE THE GROUPS LABELS TO [0-K]
        '''
        count = 1
        for i in np.unique(self.classes):
            self.classes[np.where(self.classes == i)] = count
            count += 1

    def start(self):
        self.distances()

        self.generate_graph()

        self.normatize()
